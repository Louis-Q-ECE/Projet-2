#include <stdio.h>
#include <allegro.h>

#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480
#define GRID_SIZE 40
#define PLAYER_SIZE 20
#define PLAYER_SPEED 4 // Vitesse de déplacement du joueur
#define COLOR_CHANGE_INTERVAL 100 // Temporisation de changement de couleur (5 secondes)

BITMAP *imageJ1; // Image du joueur 1
BITMAP *imageJ2; // Image du joueur 2

// Structure pour representer les joueurs
typedef struct {
    int x, y; // Position des joueurs sur le plateau
    int grabbed; // Indicateur pour savoir si le joueur a attrapé un bloc
    int grab_x, grab_y; // Position du bloc attrapé par le joueur
} Player;

// Structure pour représenter le bloc déplaçable
typedef struct {
    int x, y; // Position du bloc sur le plateau
    int grabbed; // Indicateur pour savoir si le bloc est attrapé
} Block;

// Initialiser les joueurs
Player joueur1 = {GRID_SIZE, GRID_SIZE, 0, 0};
Player joueur2 = {SCREEN_WIDTH - GRID_SIZE - PLAYER_SIZE, SCREEN_HEIGHT - GRID_SIZE - PLAYER_SIZE, 0, 0};
int staticCube_x = SCREEN_WIDTH - GRID_SIZE * 2; // Nouvelle position X du cube statique
int staticCube_y = GRID_SIZE; // Nouvelle position Y du cube statique

// Initialiser le bloc déplaçable
Block movableBlock = {SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, 0};

// Structure pour représenter un bloc lâché
typedef struct {
    int x, y; // Position du bloc lâché sur le plateau
    int color; // Couleur du bloc lâché
} DroppedBlock;

#define MAX_DROPPED_BLOCKS 10 // Nombre maximal de blocs lâchés pouvant être stockés
DroppedBlock droppedBlocks[MAX_DROPPED_BLOCKS]; // Liste des blocs lâchés
int numDroppedBlocks = 0; // Nombre actuel de blocs lâchés

int colorChangeTimer = 0; // Timer pour le changement de couleur du cube
int currentCubeColor; // Déclaration de la variable sans initialisation

int afficher_menu();
int afficher_regles();
// Fonction pour supprimer le premier bloc lâché
void supprimer_premier_bloc_lache() {
    for (int i = 0; i < numDroppedBlocks - 1; i++) {
        droppedBlocks[i] = droppedBlocks[i + 1];
    }
    numDroppedBlocks--;
}
int main() {
    // Initialisation
    allegro_init();
    install_keyboard();
    install_mouse();
    set_color_depth(32);
    set_gfx_mode(GFX_AUTODETECT_WINDOWED, SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0);
    // Initialisez currentCubeColor avec makecol ici
    currentCubeColor = makecol(255, 255, 0); // Couleur initiale du cube
    // Chargement des images des joueurs
    imageJ1 = load_bitmap("imageJ1.bmp", NULL);
    imageJ2 = load_bitmap("imageJ2.bmp", NULL);

    // Afficher le menu cliquable avec l'image
    afficher_menu();

    // Création d'une bitmap temporaire pour le double tampon
    BITMAP *buffer = create_bitmap(SCREEN_WIDTH, SCREEN_HEIGHT);

    // Boucle de jeu
    while (!key[KEY_ESC]) {
        // Si la touche 'r' est enfoncée, afficher les règles
        if (key[KEY_R]) {
            afficher_regles();
            rest(1000);
        }

        // Gestion des mouvements du joueur 1
        if (key[KEY_W]) joueur1.y -= PLAYER_SPEED;
        if (key[KEY_S]) joueur1.y += PLAYER_SPEED;
        if (key[KEY_A]) joueur1.x -= PLAYER_SPEED;
        if (key[KEY_D]) joueur1.x += PLAYER_SPEED;

        // Gestion des mouvements du joueur 2
        if (key[KEY_UP]) joueur2.y -= PLAYER_SPEED;
        if (key[KEY_DOWN]) joueur2.y += PLAYER_SPEED;
        if (key[KEY_LEFT]) joueur2.x -= PLAYER_SPEED;
        if (key[KEY_RIGHT]) joueur2.x += PLAYER_SPEED;

        // Limiter la position des joueurs dans les limites du plateau
        if (joueur1.x < GRID_SIZE) joueur1.x = GRID_SIZE;
        if (joueur1.x >= SCREEN_WIDTH - GRID_SIZE - PLAYER_SIZE) joueur1.x = SCREEN_WIDTH - GRID_SIZE - PLAYER_SIZE;
        if (joueur1.y < GRID_SIZE) joueur1.y = GRID_SIZE;
        if (joueur1.y >= SCREEN_HEIGHT - GRID_SIZE - PLAYER_SIZE) joueur1.y = SCREEN_HEIGHT - GRID_SIZE - PLAYER_SIZE;

        if (joueur2.x < GRID_SIZE) joueur2.x = GRID_SIZE;
        if (joueur2.x >= SCREEN_WIDTH - GRID_SIZE - PLAYER_SIZE) joueur2.x = SCREEN_WIDTH - GRID_SIZE - PLAYER_SIZE;
        if (joueur2.y < GRID_SIZE) joueur2.y = GRID_SIZE;
        if (joueur2.y >= SCREEN_HEIGHT - GRID_SIZE - PLAYER_SIZE) joueur2.y = SCREEN_HEIGHT - GRID_SIZE - PLAYER_SIZE;

        // Vérifier si le joueur 1 ou le joueur 2 attrape le bloc déplaçable
        if (key[KEY_SPACE]) {
            if (!joueur1.grabbed && joueur1.x + PLAYER_SIZE >= movableBlock.x && joueur1.x <= movableBlock.x + GRID_SIZE && joueur1.y + PLAYER_SIZE >= movableBlock.y && joueur1.y <= movableBlock.y + GRID_SIZE) {
                joueur1.grabbed = 1;
                joueur1.grab_x = movableBlock.x;
                joueur1.grab_y = movableBlock.y;
            }
            if (!joueur2.grabbed && joueur2.x + PLAYER_SIZE >= movableBlock.x && joueur2.x <= movableBlock.x + GRID_SIZE && joueur2.y + PLAYER_SIZE >= movableBlock.y && joueur2.y <= movableBlock.y + GRID_SIZE) {
                joueur2.grabbed = 1;
                joueur2.grab_x = movableBlock.x;
                joueur2.grab_y = movableBlock.y;
            }
        }

        // Mettre à jour la position du bloc déplaçable tenu par le joueur 1
        if (joueur1.grabbed) {
            joueur1.grab_x = joueur1.x;
            joueur1.grab_y = joueur1.y;
            movableBlock.x = joueur1.grab_x;
            movableBlock.y = joueur1.grab_y;
        }
        // Mettre à jour la position du bloc déplaçable tenu par le joueur 2
        if (joueur2.grabbed) {
            joueur2.grab_x = joueur2.x;
            joueur2.grab_y = joueur2.y;
            movableBlock.x = joueur2.grab_x;
            movableBlock.y = joueur2.grab_y;
        }
        // Mettre à jour la position du bloc déplaçable tenu
        // Gérer le lâchement du bloc déplaçable
        if (key[KEY_ENTER]) {
            if (numDroppedBlocks >= MAX_DROPPED_BLOCKS) {
                // Supprimer le premier bloc lâché pour faire de la place pour un nouveau bloc
                supprimer_premier_bloc_lache();
            }
            if (joueur1.grabbed) {
                joueur1.grabbed = 0;
                if (numDroppedBlocks < MAX_DROPPED_BLOCKS) {
                    // Ajouter le nouveau bloc lâché
                    droppedBlocks[numDroppedBlocks].x = movableBlock.x;
                    droppedBlocks[numDroppedBlocks].y = movableBlock.y;
                    droppedBlocks[numDroppedBlocks].color = currentCubeColor;
                    numDroppedBlocks++;
                }
            }
            if (joueur2.grabbed) {
                joueur2.grabbed = 0;
                if (numDroppedBlocks < MAX_DROPPED_BLOCKS) {
                    // Ajouter le nouveau bloc lâché
                    droppedBlocks[numDroppedBlocks].x = movableBlock.x;
                    droppedBlocks[numDroppedBlocks].y = movableBlock.y;
                    droppedBlocks[numDroppedBlocks].color = currentCubeColor;
                    numDroppedBlocks++;
                }
            }
        }

        // Mettre à jour la position du bloc déplaçable sur le sol s'il n'est pas tenu
        if (!joueur1.grabbed && !joueur2.grabbed) {
            movableBlock.x = staticCube_x - PLAYER_SIZE;
            movableBlock.y = staticCube_y - PLAYER_SIZE;
        }

        // Incrémenter le timer de changement de couleur
        colorChangeTimer++;
        if (colorChangeTimer >= COLOR_CHANGE_INTERVAL) {
            // Changer la couleur du cube
            currentCubeColor = makecol(rand() % 256, rand() % 256, rand() % 256);
            // Réinitialiser le timer
            colorChangeTimer = 0;
        }

        // Dessiner le plateau quadrillé avec des blocs violets sur les extrémités droite et gauche,
        // et des bords verts sur les extrémités hautes et basses sur la bitmap temporaire
        clear_bitmap(buffer); // Effacer la bitmap temporaire avant de redessiner
        for (int x = 0; x < SCREEN_WIDTH; x += GRID_SIZE) {
            for (int y = 0; y < SCREEN_HEIGHT; y += GRID_SIZE) {
                // Dessiner des blocs violets sur les extrémités droite et gauche
                if (x == 0 || x == SCREEN_WIDTH - GRID_SIZE) {
                    rectfill(buffer, x, y, x + GRID_SIZE, y + GRID_SIZE, makecol(255, 0, 255)); // Violet
                }
                    // Dessiner des bords verts sur les extrémités hautes et basses
                else if (y == 0 || y == SCREEN_HEIGHT - GRID_SIZE) {
                    rectfill(buffer, x, y, x + GRID_SIZE, y + GRID_SIZE, makecol(0, 255, 0)); // Vert
                }
                else {
                    rectfill(buffer, x, y, x + GRID_SIZE, y + GRID_SIZE, makecol(192, 192, 192)); // Gris pour le reste du plateau
                }

                // Dessiner une bordure noire autour de chaque bloc vert
                if (x == 0 || x == SCREEN_WIDTH - GRID_SIZE) {
                    rect(buffer, x, y, x + GRID_SIZE, y + GRID_SIZE, makecol(0, 0, 0));
                }
                    // Dessiner une bordure noire autour de chaque bloc violet
                else if (y == 0 || y == SCREEN_HEIGHT - GRID_SIZE) {
                    rect(buffer, x, y, x + GRID_SIZE, y + GRID_SIZE, makecol(0, 0, 0));
                }
            }
        }

        // Dessiner les blocs lâchés
        for (int i = 0; i < numDroppedBlocks; i++) {
            rectfill(buffer, droppedBlocks[i].x, droppedBlocks[i].y, droppedBlocks[i].x + GRID_SIZE, droppedBlocks[i].y + GRID_SIZE, droppedBlocks[i].color); // Utiliser la couleur stockée
        }

        // Dessiner le bloc déplaçable
        rectfill(buffer, movableBlock.x, movableBlock.y, movableBlock.x + GRID_SIZE, movableBlock.y + GRID_SIZE, currentCubeColor); // Utiliser la couleur actuelle du cube

        // Dessiner les joueurs sur la bitmap temporaire
        draw_sprite(buffer, imageJ1, joueur1.x, joueur1.y);
        draw_sprite(buffer, imageJ2, joueur2.x, joueur2.y);

        // Copier la bitmap temporaire sur l'écran
        blit(buffer, screen, 0, 0, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        // Attendre un court instant pour limiter la vitesse de déplacement
        rest(5);
    }

    // Libération des ressources Allegro
    destroy_bitmap(buffer);
    destroy_bitmap(imageJ1);
    destroy_bitmap(imageJ2);
    allegro_exit();

    return 0;
}
END_OF_MAIN()

